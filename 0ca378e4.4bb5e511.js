(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{136:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var r=n(1),o=n(9),a=(n(0),n(204)),c={},i={id:"conflux-doc/docs/design",title:"design",description:"# Conflux Design Document",source:"@site/docs/conflux-doc/docs/design.md",permalink:"/docs/conflux-doc/docs/design",editUrl:"https://github.com/Conflux-Chain/conflux-developer-site/edit/master/docs/conflux-doc/docs/design.md",lastUpdatedBy:"ConfluxBot",lastUpdatedAt:1587669089},s=[],l={rightToc:s};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"conflux-design-document"},"Conflux Design Document"),Object(a.b)("p",null,"In this document, we describe the architecture and organization of Conflux software stack and its design rationale.\nThe following figure shows the overview of the Conflux full node stack.\n",Object(a.b)("img",Object(r.a)({parentName:"p"},{src:"img/full-stack.png",alt:"Full Stack"})),"\nIt consists of several key components."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Peer-to-Peer Layer"),Object(a.b)("li",{parentName:"ul"},"Synchronization Graph"),Object(a.b)("li",{parentName:"ul"},"Consensus Graph"),Object(a.b)("li",{parentName:"ul"},"Storage Layer"),Object(a.b)("li",{parentName:"ul"},"Transaction Pool"),Object(a.b)("li",{parentName:"ul"},"Block Generator")),Object(a.b)("p",null,"Generally speaking, the peer-to-peer layer takes charge of disseminating blocks and transactions among the nodes in the entire network where each node maintains several inbound/outbound connections to its peers.\nEach node also maintains an in-memory synchronization graph data structure. When a new block is received from a peer or generated locally, the block will be first inserted into the synchronization graph where it goes through some basic validation which does not require graph-wise information.\nAt the time when a block enters the synchronization graph, its past-set blocks may not already entered.\nThe synchronization graph monitors the block and puts it into the consensus graph once all its past-set blocks enters the synchronization graph.\nWhen a block enters the consensus graph, its past-set blocks should all already entered this graph.\nThen the consensus algorithm will be conducted based on this newly arrived block to adjust the total order of blocks accordingly. The consensus graph component executes the newly arrived block and updates the account states in the storage layer. "),Object(a.b)("p",null,"Each node maintains a transaction pool that holds the to-be-packed transactions and relays the transactions to its peers that may need them.\nThe block generator component drives the mining efforts, picks transactions from the pool, and packs them into the newly generated block."),Object(a.b)("p",null,"This document is organized as in the following sections."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/conflux-doc/docs/consensus"}),"Consensus Mechanism")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/conflux-doc/docs/sync"}),"Block Synchronization Process")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object(r.a)({parentName:"li"},{href:"/docs/conflux-doc/docs/trans"}),"Transaction Relay"))))}u.isMDXComponent=!0},204:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),u=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i({},t,{},e)),n},p=function(e){var t=u(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=u(n),b=r,h=p["".concat(c,".").concat(b)]||p[b]||d[b]||a;return n?o.a.createElement(h,i({ref:t},l,{components:n})):o.a.createElement(h,i({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,c=new Array(a);c[0]=b;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,c[1]=i;for(var l=2;l<a;l++)c[l]=n[l];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);